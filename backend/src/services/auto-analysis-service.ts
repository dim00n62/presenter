// backend/src/services/auto-analysis-service.ts

import { analysisAgent } from '../agents/analysis-agent.js';
import { blueprintAgent } from '../agents/blueprint-agent.js';
import { db } from '../db/index.js';

interface AnalysisProgress {
    status: 'parsing' | 'analyzing' | 'generating_preview' | 'complete' | 'error';
    message: string;
    progress: number; // 0-100
    result?: any;
    error?: string;
}

type ProgressCallback = (progress: AnalysisProgress) => void;

export class AutoAnalysisService {
    private progressCallbacks = new Map<string, ProgressCallback[]>();

    /**
     * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞
     */
    async autoAnalyze(documentId: string, projectId: string): Promise<void> {
        try {
            // 1. Wait for parsing to complete
            await this.waitForParsing(documentId);
            this.notifyProgress(projectId, {
                status: 'parsing',
                message: '–î–æ–∫—É–º–µ–Ω—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω',
                progress: 30
            });

            // 2. Get all documents for project
            await db.db.read();
            const documents = db.db.data.documents.filter((d: any) => d.projectId === projectId);
            const documentIds = documents.map((d: any) => d.id);

            if (documentIds.length === 0) {
                throw new Error('No documents found for analysis');
            }

            // 3. Run analysis
            this.notifyProgress(projectId, {
                status: 'analyzing',
                message: '–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ...',
                progress: 40
            });

            const analysis = await analysisAgent.analyze(projectId, documentIds);

            // Save analysis
            await db.createAnalysis(analysis);

            this.notifyProgress(projectId, {
                status: 'analyzing',
                message: '–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω',
                progress: 70
            });

            // 4. Generate preview blueprint automatically
            this.notifyProgress(projectId, {
                status: 'generating_preview',
                message: '–°–æ–∑–¥–∞–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É...',
                progress: 80
            });

            const previewBlueprint = await blueprintAgent.createBlueprint(projectId, analysis);

            // Save preview blueprint with correct structure
            const blueprint = {
                projectId,
                analysisId: analysis.id,
                slides: previewBlueprint.slides,
                metadata: {
                    ...previewBlueprint.metadata,
                    isPreview: true,
                    autoGenerated: true
                },
                visualStyle: {
                    theme: 'corporate',
                    colorScheme: 'green-teal',
                    fontPrimary: 'Segoe UI',
                    fontSecondary: 'Segoe UI'
                },
                status: 'draft' as const
            };

            const savedBlueprint = await db.createBlueprint(blueprint);

            // 5. Complete
            this.notifyProgress(projectId, {
                status: 'complete',
                message: '–ì–æ—Ç–æ–≤–æ! –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∞',
                progress: 100,
                result: {
                    analysis,
                    blueprintId: savedBlueprint.id
                }
            });

        } catch (error: any) {
            console.error('Auto-analysis error:', error);
            this.notifyProgress(projectId, {
                status: 'error',
                message: error.message,
                progress: 0,
                error: error.message
            });
        }
    }

    /**
     * –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞
     */
    private async waitForParsing(documentId: string, maxWait = 60000): Promise<void> {
        const startTime = Date.now();

        while (Date.now() - startTime < maxWait) {
            const doc = await db.getDocument(documentId);

            if (doc.status === 'parsed') {
                return;
            }

            if (doc.status === 'failed') {
                throw new Error('Document parsing failed');
            }

            // Wait 1 second before checking again
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        throw new Error('Document parsing timeout');
    }

    /**
     * Register progress callback
     */
    onProgress(projectId: string, callback: ProgressCallback): () => void {
        if (!this.progressCallbacks.has(projectId)) {
            this.progressCallbacks.set(projectId, []);
        }

        this.progressCallbacks.get(projectId)!.push(callback);

        // Return unsubscribe function
        return () => {
            const callbacks = this.progressCallbacks.get(projectId);
            if (callbacks) {
                const index = callbacks.indexOf(callback);
                if (index > -1) {
                    callbacks.splice(index, 1);
                }
            }
        };
    }

    /**
     * Notify all listeners
     */
    private notifyProgress(projectId: string, progress: AnalysisProgress): void {
        console.log(`üìä Progress [${projectId}]:`, progress.message, `(${progress.progress}%)`);

        const callbacks = this.progressCallbacks.get(projectId);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(progress);
                } catch (error) {
                    console.error('Progress callback error:', error);
                }
            });
        }
    }

    /**
     * Cleanup listeners
     */
    cleanup(projectId: string): void {
        this.progressCallbacks.delete(projectId);
    }

    /**
     * Quick start - skip analysis, create basic blueprint
     */
    async quickStart(projectId: string): Promise<any> {
        try {
            await db.db.read();

            // Get document info
            const documents = db.db.data.documents.filter((d: any) => d.projectId === projectId);
            const project = db.db.data.projects.find((p: any) => p.id === projectId);

            if (!documents.length) {
                throw new Error('No documents found');
            }

            // Create minimal analysis
            const quickAnalysis = {
                projectId,
                documentIds: documents.map((d: any) => d.id),
                classification: {
                    type: 'general',
                    reasoning: 'Quick start - skipped detailed analysis',
                    confidence: 50,
                    keywords: []
                },
                entities: {
                    stakeholders: []
                },
                metrics: {},
                quality: {
                    completeness: 50,
                    clarity: 50,
                    structure: 50
                },
                recommendations: [],
                keyPoints: [],
                themes: []
            };

            const savedAnalysis = await db.createAnalysis(quickAnalysis);

            // Create minimal blueprint
            const blueprint = {
                projectId,
                analysisId: savedAnalysis.id,
                slides: [
                    {
                        id: crypto.randomUUID(),
                        type: 'title',
                        title: project?.name || '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è',
                        order: 0,
                        section: 'intro',
                        layoutType: 'title',
                        contentPriority: 'high',
                        designNotes: '–¢–∏—Ç—É–ª—å–Ω—ã–π —Å–ª–∞–π–¥',
                        estimatedComplexity: 'low'
                    },
                    {
                        id: crypto.randomUUID(),
                        type: 'content',
                        title: '–í–≤–µ–¥–µ–Ω–∏–µ',
                        order: 1,
                        section: 'intro',
                        layoutType: 'text',
                        contentPriority: 'high',
                        designNotes: '',
                        estimatedComplexity: 'medium'
                    },
                    {
                        id: crypto.randomUUID(),
                        type: 'content',
                        title: '–û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å',
                        order: 2,
                        section: 'body',
                        layoutType: 'text',
                        contentPriority: 'high',
                        designNotes: '',
                        estimatedComplexity: 'medium'
                    },
                    {
                        id: crypto.randomUUID(),
                        type: 'content',
                        title: '–ó–∞–∫–ª—é—á–µ–Ω–∏–µ',
                        order: 3,
                        section: 'conclusion',
                        layoutType: 'text',
                        contentPriority: 'high',
                        designNotes: '',
                        estimatedComplexity: 'medium'
                    }
                ],
                metadata: {
                    totalSlides: 4,
                    estimatedDuration: 8,
                    targetAudience: 'general',
                    presentationGoal: 'informative',
                    quickStart: true
                },
                visualStyle: {
                    theme: 'corporate',
                    colorScheme: 'green-teal',
                    fontPrimary: 'Segoe UI',
                    fontSecondary: 'Segoe UI'
                },
                status: 'draft' as const
            };

            const savedBlueprint = await db.createBlueprint(blueprint);

            return savedBlueprint;
        } catch (error) {
            console.error('Quick start error:', error);
            throw error;
        }
    }
}

export const autoAnalysisService = new AutoAnalysisService();